STM32 GREENHOUSE CONTROLLER
FIRMWARE DESIGN DOCUMENT
Version 1.0  Â·  Embedded C (HAL)  Â·  STM32F103

1.  SYSTEM OVERVIEW

This firmware runs on an STM32F103 microcontroller and forms the real-time control core of a smart greenhouse system. It reads temperature and humidity via a DHT sensor, drives relay-controlled actuators (fan, pump, heater), and communicates bidirectionally with a Raspberry Pi host over UART.

ðŸ“Œ  The Pi acts as the HMI and data logger. The STM32 is the safety-critical real-time controller. Even if UART comms are lost, the STM32 continues to regulate the environment using last-known setpoints.

1.1  Key Responsibilities
â–¸	Periodic sensor acquisition  â€” DHT11/22 every 2 s with CRC validation and retry
â–¸	Relay hysteresis control  â€” Prevents chatter at threshold boundaries
â–¸	UART framing  â€” ASCII protocol with fixed prefixes (DATA / SET / ACK / ERR)
â–¸	Fault handling  â€” Safe relay-off state + ERR frame on sensor failure
â–¸	Watchdog  â€” IWDG resets the MCU if the main loop stalls > 4 s

2.  FIRMWARE ARCHITECTURE

2.1  Layer Model

Layer	File(s)	Responsibility
Application Layer	main.c	Orchestrates sensor read â†’ control â†’ comms loop
Control Layer	control.c / .h	Hysteresis logic, relay state machine
Sensor Driver	dht.c / .h	DHT11/22 1-wire timing, CRC check
UART Comms	uart_comms.c / .h	Rx/Tx framing, ring buffer, ISR callback
HAL / BSP	STM32 HAL + MX init	Clock, GPIO, USART1 peripheral init

2.2  File Structure
Core/
  Src/
    main.c          â† top-level loop + init
    control.c       â† relay hysteresis state machine
    dht.c           â† DHT sensor 1-wire driver
    uart_comms.c    â† UART framing, ring buffer, ISR
  Inc/
    control.h
    dht.h
    uart_comms.h
  Startup / HAL / MX generated files

ðŸ“Œ  MX-generated files (main.h, stm32f1xx_hal_conf.h) should never be manually edited. All application logic lives in the Src/ modules above.

3.  MAIN LOOP FLOW

The superloop runs at a fixed 2-second cadence enforced by HAL_Delay(). Each iteration follows a strict read â†’ control â†’ comms order to ensure actuator decisions are always based on fresh sensor data.

3.1  Pseudocode
HAL_Init() â†’ SystemClock_Config() â†’ MX_GPIO_Init() â†’ MX_USART1_UART_Init()
UART_Init()   // start Rx interrupt + ring buffer
Control_Init() // set relay pins low, load defaults
IWDG_Start(4000ms)

while(1) {
    status = DHT_Read(&sensor)
    if (status == DHT_OK)
        Control_Update(sensor.temp, sensor.hum)
    else
        Control_Fault()              // relays OFF, send ERR

    if (UART_ParseCommand(rx_buf))   // non-blocking ring-buffer read
        Control_SetThresholds(t, h)  // update setpoints

    UART_SendData(sensor.temp, sensor.hum)
    HAL_IWDG_Refresh(&hiwdg)
    HAL_Delay(2000)
}

4.  CONTROL STATE MACHINE

The control module implements a hysteresis-based state machine to prevent relay chatter when sensor values hover near setpoints. Each relay is independently managed with configurable hysteresis bands.

State	Action	Condition	Next State
IDLE	Awaiting first sensor read	Sensor read complete	READING
READING	Read DHT, validate CRC	Valid data	CONTROLLING
READING	Read DHT, validate CRC	CRC fail (â‰¤ 3 retries)	READING
READING	Read DHT, validate CRC	3 consecutive failures	FAULT
CONTROLLING	Apply hysteresis, drive relays	Control applied	TRANSMITTING
TRANSMITTING	Send DATA frame to Pi over UART	Tx complete	RECEIVING
RECEIVING	Check for incoming SET command	CMD received or timeout	IDLE
FAULT	All relays OFF, send ERR frame	Watchdog reset	IDLE

4.1  Hysteresis Values (Default)
Parameter	Default	Macro Name
Temp ON threshold	> set_temp	â€”
Temp hysteresis	Â± 0.5 Â°C	TEMP_HYST
Hum ON threshold	< set_hum	â€”
Hum hysteresis	Â± 2.0 %RH	HUM_HYST

5.  UART COMMUNICATION PROTOCOL

UART1 is configured at 9600 baud, 8-N-1. All frames are ASCII-printable, terminated with \r\n, and prefixed with a 3-4 character type identifier. Maximum frame length is 32 bytes.

Direction	Type	Frame Example	Purpose
Pi â†’ STM32	SET	SET:T=25.0,H=80.0\r\n	Set target temperature & humidity
Pi â†’ STM32	PING	PING\r\n	Heartbeat / connection check
STM32 â†’ Pi	DATA	DATA:T=24.5,H=78.2\r\n	Live sensor reading
STM32 â†’ Pi	ACK	ACK:SET\r\n	Acknowledge SET command
STM32 â†’ Pi	ERR	ERR:DHT_FAIL\r\n	Sensor or system fault
STM32 â†’ Pi	PONG	PONG\r\n	Reply to PING

5.1  Reception Architecture
Reception is interrupt-driven. HAL_UART_Receive_IT() is called after each byte. The ISR appends bytes to a 128-byte ring buffer. The main loop calls UART_ParseCommand() which drains the ring buffer looking for a complete \r\n-terminated frame.

ðŸ“Œ  This design means the main loop is never blocked waiting for UART data. A 100 ms timeout on reception is not needed and has been removed from the improved design.

6.  GPIO & PIN ASSIGNMENT

Pin	Dir	Label	Description
PA1	Output	FAN_PIN	Relay 1 â€” Cooling fan
PA2	Output	PUMP_PIN	Relay 2 â€” Humidifier pump
PA3	Output	HEAT_PIN	Relay 3 â€” Heater (optional)
PB0	Input	DHT_DATA	DHT11/22 data line (open-drain + pull-up)
PA9	AF	USART1_TX	UART transmit to Raspberry Pi
PA10	AF	USART1_RX	UART receive from Raspberry Pi
PC13	Output	STATUS_LED	Heartbeat / fault indicator LED

ðŸ“Œ  DHT data pin requires a 4.7 kÎ© pull-up resistor to 3.3 V. Relay pins drive optocoupler inputs â€” ensure current-limiting resistors are fitted on the PCB.

7.  MODULE API REFERENCE

Module	Function Signature	Description
control.h	void Control_Init(void)	Initialise relay GPIOs, set default thresholds
control.h	void Control_Update(float t, float h)	Run hysteresis logic, drive relay pins
control.h	void Control_SetThresholds(float t, float h)	Update setpoints from parsed UART command
control.h	Control_State_t Control_GetState(void)	Return current FAN / PUMP / HEAT bitmask
dht.h	DHT_Status_t DHT_Read(DHT_Data_t *out)	Read sensor; fills temp & hum; returns OK/ERR
dht.h	const char* DHT_StatusStr(DHT_Status_t s)	Human-readable status string for logging
uart_comms.h	void UART_Init(void)	Set up ring buffer, start Rx interrupt
uart_comms.h	void UART_SendData(float t, float h)	Format & transmit DATA frame
uart_comms.h	bool UART_ParseCommand(char *buf)	Parse rx buffer; returns true if SET received

8.  ERROR HANDLING & SAFETY

8.1  DHT Sensor Failures
â–¸	Up to 3 consecutive read retries before declaring FAULT state
â–¸	On FAULT: all relays are forced OFF (safe, cold-dry default)
â–¸	ERR:DHT_FAIL frame is sent to Pi so the operator is alerted
â–¸	IWDG watchdog resets MCU after 4 s if loop stalls in FAULT

8.2  UART Failures
â–¸	Receive timeout is non-blocking â€” missed commands do not stall the loop
â–¸	rx_data buffer is cleared (memset) before each receive attempt
â–¸	sscanf return value validated â€” partial frames are silently discarded
â–¸	Setpoint sanity bounds enforced: T âˆˆ (0, 60 Â°C), H âˆˆ (0, 100 %)

8.3  Relay Safety Rules
ðŸ“Œ  Relays must NEVER be driven simultaneously if the load circuit cannot support concurrent operation. Add a mutual-exclusion check in Control_Update() if fan + heater share the same power rail.

9.  CONFIGURATION & BUILD

9.1  Compile-Time Defines  (control.h)
#define TEMP_HYST          0.5f    // Â°C
#define HUM_HYST           2.0f    // %RH
#define DHT_MAX_RETRIES    3
#define UART_RX_BUF_SIZE   128
#define UART_TX_BUF_SIZE   64
#define LOOP_PERIOD_MS     2000
#define IWDG_TIMEOUT_MS    4000

9.2  Default Setpoints  (adjustable via UART SET command)
#define DEFAULT_SET_TEMP   25.0f   // Â°C
#define DEFAULT_SET_HUM    80.0f   // %RH

9.3  Toolchain
â–¸	STM32CubeIDE 1.14+  or  arm-none-eabi-gcc 12+
â–¸	HAL library: STM32CubeF1 v1.8.5
â–¸	Flash via ST-Link V2 or DFU over USB

10.  FUTURE IMPROVEMENTS

â–¸	DMA-based UART  â€” Replace interrupt Rx/Tx with DMA for zero CPU overhead
â–¸	PID control  â€” Replace on/off relay logic with PWM + PID for smoother regulation
â–¸	EEPROM/Flash storage  â€” Persist setpoints across power cycles using emulated EEPROM
â–¸	FreeRTOS  â€” Separate sensor, control, and comms into independent tasks
â–¸	Multiple sensors  â€” Support SHT31 over I2C as a higher-accuracy fallback
â–¸	OTA update  â€” Bootloader with UART or CAN-based firmware update capability

Document generated from code review â€” update version number and author field before distributing.
